<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Software Tutorial: Modeling a Pure Random Walk Strategy - Biological Modeling: A Free Online Course</title>
<meta name="description" content="A free and open online course in biological modeling at multiple scales.">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Biological Modeling: A Free Online Course">
<meta property="og:title" content="Software Tutorial: Modeling a Pure Random Walk Strategy">
<meta property="og:url" content="/chemotaxis/tutorial_purerandom">


  <meta property="og:description" content="A free and open online course in biological modeling at multiple scales.">












<link rel="canonical" href="/chemotaxis/tutorial_purerandom">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>







<!-- end _includes/seo.html -->


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">



<!--SEO tagging -->
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Software Tutorial: Modeling a Pure Random Walk Strategy | Biological Modeling: A Free Online Course</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Software Tutorial: Modeling a Pure Random Walk Strategy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A free and open online course in biological modeling at multiple scales." />
<meta property="og:description" content="A free and open online course in biological modeling at multiple scales." />
<meta property="og:site_name" content="Biological Modeling: A Free Online Course" />
<meta property="og:image" content="/assets/images/chemotaxis_traj_1.0.png" />
<script type="application/ld+json">
{"description":"A free and open online course in biological modeling at multiple scales.","@type":"WebPage","url":"/chemotaxis/tutorial_purerandom","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/gray_scott_jupyter_3.png"}},"image":"/assets/images/chemotaxis_traj_1.0.png","headline":"Software Tutorial: Modeling a Pure Random Walk Strategy","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-173522486-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-173522486-1');
</script>

    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Biological Modeling: A Free Online Course</a>
        <ul class="visible-links">
                
                
                    <li class="masthead__menu-item">
                        <a href="/meet-the-team/">Course Team</a>
                    </li>
                
            
                
                
                    <li class="masthead__menu-item">
                        <a href="/contact/">Contact Us</a>
                    </li>
                
            
                
                
                    <li class="masthead__menu-item">
                        <a href="/contents/">Contents</a>
                    </li>
                
            
                
                
                    <li class="dropdown ">
                        <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Take the Course    <i class="fa fa-caret-down fa-sm" aria-hidden="true"></i><span class="caret"></span></a>
                        <ul class="dropdown-content">
                            
                                <li>
                                    <a href="/prologue/">    <b>Prologue:</b> an introduction to biological modeling via random walks and Turing patterns</a>
                                </li>
                            
                                <li>
                                    <a href="/motifs/home">    <b>Module 1:</b> Finding motifs in transcription factor networks</a>
                                </li>
                            
                                <li>
                                    <a href="/chemotaxis/home">    <b>Module 2:</b> Unpacking E. coli's genius exploration algorithm</a>
                                </li>
                            
                                <li>
                                    <a href="/coronavirus/home">    <b>Module 3:</b> Analyzing the coronavirus spike protein</a>
                                </li>
                            
                                <li>
                                    <a href="">    <b>Module 4:</b> coming soon!</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Unpacking E. coli's Genius Exploration Algorithm</span>
        

        
        <ul>
          
            <li><a href="/chemotaxis/home">Introduction: The lost immortals<br><br></a></li>
          
            <li><a href="/chemotaxis/home_walk">Bacterial runs and tumbles<br><br></a></li>
          
            <li><a href="/chemotaxis/home_signal">Signaling & ligand-receptor dynamics<br><br></a></li>
          
            <li><a href="/chemotaxis/home_signalpart2">Stochastic simulation of chemical reactions<br><br></a></li>
          
            <li><a href="/chemotaxis/home_biochemistry">A biochemically accurate model of bacterial chemotaxis<br><br></a></li>
          
            <li><a href="/chemotaxis/home_adaptation">Methylation helps a bacterium adapt to differing concentrations<br><br></a></li>
          
            <li><a href="/chemotaxis/home_gradient">Modeling a bacterium's response to an attractant gradient<br><br></a></li>
          
            <li><a href="/chemotaxis/home_conclusion">Conclusion: the beauty of E. coli's robust randomized exploration algorithm<br><br></a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Software Tutorials (featuring BioNetGen)</span>
        

        
        <ul>
          
            <li><a href="/chemotaxis/tutorial_lr">Getting started wtih BioNetGen and modeling ligand-receptor dynamics<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_phos">Adding phosphorylation to our BioNetGen model<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_adaptation">Modeling bacterial adaptation to changing attractant<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_gradient">Traveling up an attractant gradient<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_removal">Traveling down an attractant gradient<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_purerandom" class="active">Modeling a pure random walk strategy<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_walk">Modeling E. coli's sophisticated random walk algorithm<br><br></a></li>
          
            <li><a href="/chemotaxis/tutorial_tumbling_frequencies">Comparing different chemotaxis default tumbling frequencies</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Exercises</span>
        

        
        <ul>
          
            <li><a href="/chemotaxis/home_exercise">Exercises on Chemotaxis<br><br></a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Software Tutorial: Modeling a Pure Random Walk Strategy">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Software Tutorial: Modeling a Pure Random Walk Strategy
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#converting-a-run-and-tumble-model-to-a-random-walk-simulation">Converting a run-and-tumble model to a random walk simulation</a></li><li><a href="#visualizing-simulated-cell-trajectories">Visualizing simulated cell trajectories</a></li><li><a href="#quantifying-the-performance-of-our-search-algorithm">Quantifying the performance of our search algorithm</a></li></ul>

            </nav>
          </aside>
        
        <p>In this tutorial, we will simulate a random walk and take a look at how well this allows a bacterium to reach a goal. You might not anticipate that the random walk will do a very good job of this – and you would not be wrong – but it will give us a baseline simple strategy to compare against a more advanced random walk strategy.</p>

<p>Specifically, we will build a Jupyter notebook to do so. You can create a blank file called <code class="language-plaintext highlighter-rouge">chemotaxis_std_random.ipynb</code> and type along, but the notebook will be quite lengthy, so feel free to download the final notebook here if you like: <a href="../downloads/downloadable/chemotaxis_std_random.ipynb" download="chemotaxis_std_random.ipynb">chemotaxis_std_random.ipynb</a>. A detailed explanation of the model and each function can be found in this completed file as well as the tutorial below.</p>

<p>Make sure that the following dependencies are installed:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Installation Link</th>
      <th style="text-align: center">Version</th>
      <th style="text-align: right">Check install/version</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><a href="https://www.python.org/downloads/">Python3</a></td>
      <td style="text-align: center">3.6+</td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">python --version</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="https://jupyter.org/index.html">Jupyter Notebook</a></td>
      <td style="text-align: center">4.4.0+</td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">jupyter --version</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="https://numpy.org/install/">Numpy</a></td>
      <td style="text-align: center">1.14.5+</td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">pip list | grep numpy</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="https://matplotlib.org/users/installing.html">Matplotlib</a></td>
      <td style="text-align: center">3.0+</td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">pip list | grep matplotlib</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="https://python-colorspace.readthedocs.io/en/latest/installation.html">Colorspace</a> or with <a href="https://pypi.org/project/colorspace/">pip</a></td>
      <td style="text-align: center">any</td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">pip list | grep colorspace</code></td>
    </tr>
  </tbody>
</table>

<h2 id="converting-a-run-and-tumble-model-to-a-random-walk-simulation">Converting a run-and-tumble model to a random walk simulation</h2>

<p>Our model will be based on observations from our BioNetGen simulation and known biology of <em>E. coli</em>. We summarize this simulation, discussed in the main text, as follows.</p>

<ol>
  <li><strong>Run.</strong> The duration of a cell’s run follows an exponential distribution with mean equal to the background run duration <code class="language-plaintext highlighter-rouge">time_exp</code>.</li>
  <li><strong>Tumble.</strong> The duration of a cell’s tumble follows an exponential distribution with mean 0.1s<sup id="fnref:Saragosti2012" role="doc-noteref"><a href="#fn:Saragosti2012" class="footnote">1</a></sup>. When it tumbles, we assume it only changes its orientation for the next run but doesn’t move in space. The degree of reorientation is a random number sampled uniformly between 0° and 360°.</li>
  <li><strong>Gradient.</strong> We model an exponential gradient with a goal (1500, 1500) having a concentration of 10<sup>8</sup>. All cells start at the origin (0, 0), which has a concentration of 10<sup>2</sup>. The ligand concentration at a point (<em>x</em>, <em>y</em>) is given by <em>L</em>(<em>x</em>, <em>y</em>) = 100 · 10<sup>8 · (1-<em>d</em>/<em>D</em>)</sup>, where <em>d</em> is the distance from (<em>x</em>, <em>y</em>) to the goal, and <em>D</em> is the distance from the origin to the goal; in this case, <em>D</em> is 1500√2 ≈ 2121 µm.</li>
</ol>

<p>First, we will import all packages needed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">patches</span>
<span class="kn">import</span> <span class="nn">colorspace</span>
</code></pre></div></div>

<p>Next, we specify all the model parameters:</p>

<ul>
  <li>mean tumble time: 0.1s;</li>
  <li>cell speed of 20µm/s<sup id="fnref:Baker2005" role="doc-noteref"><a href="#fn:Baker2005" class="footnote">2</a></sup>.</li>
</ul>

<p>We also set a “seed” of our pseudorandom number generator to ensure that the sequence of “random” numbers given to us by Python will be the same every time we run the simulation. To obtain a different outcome, change the seed.</p>

<p class="notice--warning"><strong>Note:</strong> For more on seeding, please consult the discussion of pseudorandom number generation at <a href="http://compeau.cbd.cmu.edu/programming-for-lovers/chapter-2-forecasting-a-presidential-election-with-monte-carlo-simulation/#pitfalls">Programming for Lovers</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SEED</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1">#Any random seed
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span> <span class="c1">#set seed for Numpy random number generator
</span>
<span class="c1">#Constants for E.coli tumbling
</span><span class="n">tumble_time_mu</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1">#second
</span>
<span class="c1">#E.coli movement constants
</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">20</span>         <span class="c1">#um/s, speed of E.coli movement
</span>
<span class="c1">#Model constants
</span><span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1">#All cells start at [0, 0]
</span><span class="n">ligand_center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1500</span><span class="p">,</span> <span class="mi">1500</span><span class="p">]</span> <span class="c1">#Position of highest concentration
</span><span class="n">center_exponent</span><span class="p">,</span> <span class="n">start_exponent</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span> <span class="c1">#exponent for concentration at [1500, 1500] and [0, 0]
</span><span class="n">origin_to_center</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#Distance from start to center, intialized here, will be actually calculated later
</span><span class="n">saturation_conc</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">8</span> <span class="c1">#From BNG model
</span></code></pre></div></div>

<p>We now will have two functions that will establish the ligand concentration at a given point (<em>x</em>, <em>y</em>) as equal to <em>L</em>(<em>x</em>, <em>y</em>) = 100 · 10<sup>8 · (1-<em>d</em>/<em>D</em>)</sup>.</p>

<p>First, we introduce a function to compute the distance between two points in two-dimensional space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculates distance between point a and b
# Input: positions a, b. Each in the form array [x, y]
# Returns the distance, a float.
</span><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we define a function to determine the concentration of ligand at a given position according to our formula, which will use <code class="language-plaintext highlighter-rouge">distance</code> as a subroutine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculates the concentration of a given position
# Exponential gradient, the exponent follows a linear relationship with distance to center
# Input: position pos, [x, y]
# Returns the concentration, a float.
</span><span class="k">def</span> <span class="nf">calc_concentration</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">ligand_center</span><span class="p">)</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">origin_to_center</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">center_exponent</span> <span class="o">-</span> <span class="n">start_exponent</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_exponent</span>

    <span class="k">return</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">exponent</span>
</code></pre></div></div>

<p>The following <code class="language-plaintext highlighter-rouge">tumble_move</code> function chooses a direction of movement as a uniform random number between 0 and 2π radians. As noted previously, the duration of a cell’s tumble follows an exponential distribution with mean equal to 0.1s.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Samples the new direction and time of a tumble
# Calculates projection on the Horizontal and Vertical direction for the next move
# No input
# Return the horizontal movement projection (float), the vertical one (float), tumble time (float)
</span><span class="k">def</span> <span class="nf">tumble_move</span><span class="p">():</span>
    <span class="c1">#Sample the new direction unformly from 0 to 2pi, record as a float
</span>    <span class="n">new_dir</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="n">projection_h</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span> <span class="c1">#displacement projected on Horizontal direction for next run, float
</span>    <span class="n">projection_v</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span> <span class="c1">#displacement projected on Vertical direction for next run, float
</span>
    <span class="c1">#Length of the tumbling sampled from exponential distribution with mean=0.1, float
</span>    <span class="n">tumble_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tumble_time_mu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">projection_h</span><span class="p">,</span> <span class="n">projection_v</span><span class="p">,</span> <span class="n">tumble_time</span>
</code></pre></div></div>

<p>In a given run of the simulation, we keep track of the total time <code class="language-plaintext highlighter-rouge">t</code>, and we only continue our simulation if <code class="language-plaintext highlighter-rouge">t</code> &lt; <code class="language-plaintext highlighter-rouge">duration</code>, where <code class="language-plaintext highlighter-rouge">duration</code> is a parameter indicating how long to run the simulation. If <code class="language-plaintext highlighter-rouge">t</code> &lt; <code class="language-plaintext highlighter-rouge">duration</code>, then we apply the following steps to a given cell.</p>

<ul>
  <li>Sample the run duration <code class="language-plaintext highlighter-rouge">curr_run_time</code> from an exponential distribution with mean <code class="language-plaintext highlighter-rouge">time_exp</code>;</li>
  <li>run for <code class="language-plaintext highlighter-rouge">curr_run_time</code> seconds in the current direction;</li>
  <li>sample the duration of tumble <code class="language-plaintext highlighter-rouge">tumble_time</code>;</li>
  <li>determine the new direction of the simulated bacterium by calling the <code class="language-plaintext highlighter-rouge">tumble_move</code> function discussed above;</li>
  <li>increment <code class="language-plaintext highlighter-rouge">t</code> by <code class="language-plaintext highlighter-rouge">curr_run_time</code> and <code class="language-plaintext highlighter-rouge">tumble_time</code>.</li>
</ul>

<p>These steps are achieved by the <code class="language-plaintext highlighter-rouge">simulate_std_random</code> function below, which takes the number of cells <code class="language-plaintext highlighter-rouge">num_cells</code> to simulate, the time to run each simulation for <code class="language-plaintext highlighter-rouge">duration</code>, and the mean time of a single run <code class="language-plaintext highlighter-rouge">time_exp</code>. This function stores the trajectories of these cells in a variable named <code class="language-plaintext highlighter-rouge">path</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This function performs simulation
# Input: number of cells to simulate (int), how many seconds (int), the expected run time before tumble (float)
# Return: the simulated trajectories path: array of shape (num_cells, duration+1, 2)
</span><span class="k">def</span> <span class="nf">simulate_std_random</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">run_time_expected</span><span class="p">):</span>

    <span class="c1">#Takes the shape (num_cells, duration+1, 2)
</span>    <span class="c1">#any point [x,y] on the simulated trajectories can be accessed via path[cell, time]
</span>    <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">duration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cells</span><span class="p">):</span>
        <span class="c1"># Initialize simulation
</span>        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#record the time elapse
</span>        <span class="n">curr_position</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="c1">#start at [0, 0]
</span>        <span class="n">curr_direction</span><span class="p">,</span> <span class="n">projection_h</span><span class="p">,</span> <span class="n">projection_v</span><span class="p">,</span> <span class="n">tumble_time</span> <span class="o">=</span> <span class="n">tumble_move</span><span class="p">()</span> <span class="c1">#Initialize direction randomly
</span>        <span class="n">past_sec</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">:</span>

            <span class="c1">#run
</span>            <span class="n">curr_run_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">run_time_expected</span><span class="p">)</span> <span class="c1">#get run duration, float
</span>            <span class="c1">#displacement on either direction is calculated as the projection * speed * time
</span>            <span class="c1">#update current position by summing old position and displacement
</span>            <span class="n">curr_position</span> <span class="o">=</span> <span class="n">curr_position</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">projection_h</span><span class="p">,</span> <span class="n">projection_v</span><span class="p">])</span> <span class="o">*</span> <span class="n">speed</span> <span class="o">*</span> <span class="n">curr_run_time</span>

            <span class="c1">#tumble
</span>            <span class="n">curr_direction</span><span class="p">,</span> <span class="n">projection_h</span><span class="p">,</span> <span class="n">projection_v</span><span class="p">,</span> <span class="n">tumble_time</span> <span class="o">=</span> <span class="n">tumble_move</span><span class="p">()</span>

            <span class="c1">#increment time
</span>            <span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">curr_run_time</span> <span class="o">+</span> <span class="n">tumble_time</span><span class="p">)</span>

            <span class="c1">#record position approximate for integer number of second
</span>            <span class="n">curr_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">past_sec</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">curr_sec</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1">#fill values from last time point to current time point
</span>                <span class="n">path</span><span class="p">[</span><span class="n">rep</span><span class="p">,</span> <span class="n">sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_position</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">past_sec</span><span class="o">=</span> <span class="n">curr_sec</span>

    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<p>Now that we have established parameters and written the functions that we will need, we will run our simulation with <code class="language-plaintext highlighter-rouge">num_cells</code> equal to 3 and <code class="language-plaintext highlighter-rouge">duration</code> equal to 500 to get a rough idea of what the trajectories of our simulated cells will look like.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Run simulation for 3 cells with different background tumbling frequencies, Plot path
</span>
<span class="n">duration</span> <span class="o">=</span> <span class="mi">800</span>  <span class="c1">#seconds, duration of the simulation, int
</span><span class="n">num_cells</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1">#number of cells, int
</span><span class="n">origin_to_center</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ligand_center</span><span class="p">)</span> <span class="c1">#Update the global constant
</span><span class="n">run_time_expected</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#expected run time before tumble, float
</span>
<span class="c1">#Calls the simulate function
</span><span class="n">path</span> <span class="o">=</span> <span class="n">simulate_std_random</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">run_time_expected</span><span class="p">)</span> <span class="c1">#get the simulated trajectories
</span><span class="k">print</span><span class="p">(</span><span class="n">path</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span> <span class="c1">#print the terminal poistion of each simulation
</span></code></pre></div></div>

<h2 id="visualizing-simulated-cell-trajectories">Visualizing simulated cell trajectories</h2>

<p>Now that we have generated the data of our randomly walking cells, our next step is to plot these trajectories using Matplotlib. We will color-code the background ligand concentration. The ligand concentrations at each position (<em>a</em>, <em>b</em>) where <em>a</em> and <em>b</em> are both integers can be represented using a matrix, and we take the logarithm of each value of this matrix to better color our exponential gradient. That is, a value of 10<sup>8</sup> will be converted to 8, and a value of 10<sup>4</sup> will be converted to 4. A white background color will indicate a low ligand concentration, while red indicates high concentration.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Below are all for plotting purposes
#Initialize the plot with 1*1 subplot of size 8*8
</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1">#First set color map to color-code the concentration
</span><span class="n">mycolor</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span> <span class="p">[</span><span class="mi">256</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">254</span><span class="p">],</span> <span class="p">[</span><span class="mi">256</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="p">[</span><span class="mi">256</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">240</span><span class="p">],</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">236</span><span class="p">,</span> <span class="mi">209</span><span class="p">],</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">218</span><span class="p">,</span> <span class="mi">185</span><span class="p">],</span> <span class="p">[</span><span class="mi">251</span><span class="p">,</span> <span class="mi">196</span><span class="p">,</span> <span class="mi">171</span><span class="p">],</span> <span class="p">[</span><span class="mi">248</span><span class="p">,</span> <span class="mi">173</span><span class="p">,</span> <span class="mi">157</span><span class="p">],</span> <span class="p">[</span><span class="mi">244</span><span class="p">,</span> <span class="mi">151</span><span class="p">,</span> <span class="mi">142</span><span class="p">],</span> <span class="p">[</span><span class="mi">240</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">]]</span> <span class="c1">#RGB values, from coolors：）
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mycolor</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
        <span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">256</span><span class="p">)</span> <span class="c1">#normalize to 0~1 range
</span><span class="n">cmap_color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">.</span><span class="n">LinearSegmentedColormap</span><span class="p">.</span><span class="n">from_list</span><span class="p">(</span><span class="s">'my_list'</span><span class="p">,</span> <span class="n">mycolor</span><span class="p">)</span> <span class="c1">#Linearly segment these colors to create a continuous color map
</span>
<span class="c1">#Store the concentrations for each integer position in a matrix
</span><span class="n">conc_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">))</span> <span class="c1">#we will display from [-1000, -1000] to [3000, 3000]
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4000</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4000</span><span class="p">):</span>
        <span class="n">conc_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">calc_concentration</span><span class="p">([</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1000</span><span class="p">]))</span> <span class="c1">#calculate the exponents of concentrations at each location
</span>
<span class="c1">#Simulate the gradient distribution, plot as a heatmap
</span><span class="n">ax</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">conc_matrix</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_color</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">],</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">'lower'</span><span class="p">)</span>

</code></pre></div></div>

<p>Next, we plot each cell’s trajectory over each of its tumbling points. To visualize older vs. newer time points, we set the color as a function of <code class="language-plaintext highlighter-rouge">t</code> so that newer points have lighter colors.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">#Plot simulation results
</span><span class="n">time_frac</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">duration</span>
<span class="c1">#Plot the trajectories. Time progress: dark -&gt; colorful
</span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s">'o'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s">'o'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.85</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s">'o'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">time_frac</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">'ko'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#Mark the starting point [0, 0]
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cells</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s">'ro'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#Mark the terminal points for each cell
</span>
</code></pre></div></div>

<p>We mark the starting point of each cell’s trajectory with a black dot and the ending point of the trajectory with a red dot. We place a blue cross over the goal. Finally, we set axis limits, assign axis labels, and generate the plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">1500</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="s">'bX'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#Mark the highest concentration point [1500, 1500]
</span><span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"Pure random walk </span><span class="se">\n</span><span class="s"> Background: avg tumble every {} s"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">run_time_exped</span><span class="p">),</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.87</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">"poisiton in um"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">"poisiton in um"</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p class="notice--primary"><strong>STOP:</strong> Run the notebook. What do you observe? Are the cells moving up the gradient? Is this a good strategy for a bacterium to use to search for food?</p>

<h2 id="quantifying-the-performance-of-our-search-algorithm">Quantifying the performance of our search algorithm</h2>

<p>We already know from our work in previous modules that a random walk simulation can produce very different outcomes. In order to assess the performance of the random walk algorithm, we will simulate <code class="language-plaintext highlighter-rouge">num_cells</code> = 500 cells and <code class="language-plaintext highlighter-rouge">duration</code> = 1500 seconds.</p>

<p>Visualizing the trajectories for this many cells will be messy. Instead, we will measure the distance between each cell and the target at the end of the simulation, and then take the average and standard deviation of this value over all cells.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Run simulation for 500 cells, plot average distance to highest concentration point
</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1500</span>   <span class="c1">#seconds, duration of the simulation
</span><span class="n">num_cells</span> <span class="o">=</span> <span class="mi">500</span> <span class="c1">#number of cells, intorigin_to_center = distance(start, ligand_center) #Update the global constant
</span><span class="n">origin_to_center</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ligand_center</span><span class="p">)</span> <span class="c1">#Update the global constant
</span><span class="n">run_time_expected</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#expected run time before tumble, float
</span>
<span class="n">all_distance</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">duration</span><span class="p">))</span> <span class="c1">#Initialize to store results, array with shape (num_cells, duration)
</span>
<span class="n">paths</span> <span class="o">=</span> <span class="n">simulate_std_random</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">run_time_expected</span><span class="p">)</span> <span class="c1">#run simulation
</span>
<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cells</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">cell</span><span class="p">,</span> <span class="n">time</span><span class="p">]</span> <span class="c1">#get the position [x,y] for the cell at a given time
</span>        <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">ligand_center</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="c1">#calculate the Euclidean distance between that position to [1500, 1500]
</span>        <span class="n">all_distance</span><span class="p">[</span><span class="n">cell</span><span class="p">,</span> <span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="c1">#record this distance
</span>
<span class="c1"># For all time, take average and standard deviation over all cells.
</span><span class="n">all_dist_avg</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_distance</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#Calculate average over cells, array of shape (duration,)
</span><span class="n">all_dist_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">all_distance</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#Calculate the standard deviation, array of shape (duration,)
</span></code></pre></div></div>

<p>We will then plot the average and standard deviation of the distance to goal using the <code class="language-plaintext highlighter-rouge">plot</code> and <code class="language-plaintext highlighter-rouge">fill_between</code> functions.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Below are all for plotting purposes
#Define the colors to use
</span><span class="n">colors1</span> <span class="o">=</span> <span class="n">colorspace</span><span class="p">.</span><span class="n">qualitative_hcl</span><span class="p">(</span><span class="n">h</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">300.</span><span class="p">],</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">pallete</span> <span class="o">=</span> <span class="s">"dynamic"</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="c1">#Set the x-axis for plot: time points. Array of integers of shape (duration,)
</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">#Initialize the plot with 1*1 subplot of size 10*8
</span>
<span class="n">mu</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">all_dist_avg</span><span class="p">,</span> <span class="n">all_dist_std</span>
<span class="c1">#Plot average distance vs. time
</span><span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"pure random walk, back ground tumble every {} second"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">run_time_expected</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">colors1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#Fill in average +/- one standard deviation vs. time
</span><span class="n">ax</span><span class="p">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">sig</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">colors1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"Average distance to highest concentration"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'time (s)'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'distance to center (µm)'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s">'gray'</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s">'dashed'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'concentration 10^8'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'upper right'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">grid</span><span class="p">()</span>
</code></pre></div></div>

<p class="notice--primary"><strong>STOP:</strong> Before visualizing the average distances at each time step, what do you expect the average distance to the goal to be?</p>

<p>Now, run the notebook. The colored line indicates average distance of the 500 cells; the shaded area is standard deviation; and the grey dashed line corresponds to a maximum ligand concentration of 10<sup>8</sup>.</p>

<p>As mentioned, you may not be surprised that this simple random walk strategy is not very effective at finding the goal. Not to worry: in the main text, we discuss how to adapt this strategy into one that better reflects how <em>E. coli</em> explores its environment based on what we have learned in this module about chemotaxis.</p>

<p style="font-size: 100%; text-align: center;"><a href="home_conclusion#strategy-2-chemotactic-random-walk" class="btn btn--primary btn--large">Return to main text</a></p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Saragosti2012" role="doc-endnote">
      <p>Saragosti J., Siberzan P., Buguin A. 2012. Modeling <em>E. coli</em> tumbles by rotational diffusion. Implications for chemotaxis. PLoS One 7(4):e35412. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3329434/">available online</a>. <a href="#fnref:Saragosti2012" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Baker2005" role="doc-endnote">
      <p>Baker MD, Wolanin PM, Stock JB. 2005. Signal transduction in bacterial chemotaxis. BioEssays 28:9-22. <a href="https://pubmed.ncbi.nlm.nih.gov/16369945/">Available online</a> <a href="#fnref:Baker2005" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        
      </section>

      <footer class="page__meta">
        
        


        

      </footer>

      

      
    </div>

    
  </article>

  <!-- only show related on a post page when `related: true`
  
  
  -->
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><div class="search-searchbar"></div>
  <div class="search-hits"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <hr>
  <table>
<tbody>
<tr>
<td><a href="http://cbd.cmu.edu" target="_blank"><img src="../assets/images/CMU_CBD_logos.png" alt="CBD Logo"></a></td>
<td><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.</a></td>
<td><a href="http://mmbios.pitt.edu" target="_blank"><img src="../assets/images/MMBioS_Logo.png" alt="MMBioS Logo"></a></td>
</tr>
</tbody>
</table>
</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>


<!-- Including InstantSearch.js library and styling -->
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch-theme-algolia.min.css">

<script>
// Instanciating InstantSearch.js with Algolia credentials
const search = instantsearch({
  appId: 'O24616B64D',
  apiKey: '3d5df9a350e2a9a5039314b58ef8c32d',
  indexName: 'biological_modeling',
  searchParameters: {
    restrictSearchableAttributes: [
      'title',
      'content'
    ]
  }
});

const hitTemplate = function(hit) {
  const url = hit.url;
  const title = hit._highlightResult.title.value;
  const content = hit._highlightResult.html.value;

  return `
    <div class="list__item">
      <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
        <h2 class="archive__item-title" itemprop="headline"><a href="${url}">${title}</a></h2>
        <div class="archive__item-excerpt" itemprop="description">${content}</div>
      </article>
    </div>
  `;
}

// Adding searchbar and results widgets
search.addWidget(
  instantsearch.widgets.searchBox({
    container: '.search-searchbar',
    poweredBy: true,
    placeholder: 'Enter your search term...'
  })
);
search.addWidget(
  instantsearch.widgets.hits({
    container: '.search-hits',
    templates: {
      item: hitTemplate,
      empty: 'No results',
    }
  })
);

// Starting the search only when toggle is clicked
$(document).ready(function () {
  $(".search__toggle").on("click", function() {
    if(!search.started) {
      search.start();
    }
  });
});
</script>








  </body>
</html>
